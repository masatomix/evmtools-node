# ブレインストーミング: 設計書駆動開発フロー

**日付**: 2025-12-16
**参加者**: masatomix, Claude
**ステータス**: ブレスト完了、次のアクション検討中

---

## 1. 背景・課題

既存プロジェクト（evmtools-node）において、以下の課題がある：

- DDD/クリーンアーキテクチャに準拠していない箇所が存在
- 正式なテストフレームワークが未導入
- 要件 → 設計 → テスト → 実装 のトレーサビリティがない

---

## 2. 理想とする開発フロー

### 2.1 目的

**要件からテストケース・実装までの一貫したトレーサビリティを確保する**

- 設計書を中心に据え、要件の反映確認とコード生成を両立させる
- 人間が読んで確認でき、かつ機械がコードを生成できる形式を採用する

### 2.2 フロー全体像

```
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  【フォワード】(メイン)         【リバース】(サブ)           │
│   要件 → 設計書                 ソース → 設計書             │
│        │                              │                    │
│        │                              ▼                    │
│        │                     ┌─────────────────┐           │
│        │                     │ 人間が補足      │           │
│        │                     │ ・なぜそうなっているか      │
│        │                     │ ・要件との紐付け│           │
│        │                     └────────┬────────┘           │
│        │                              │                    │
│        └──────────────┬───────────────┘                    │
│                       ▼                                    │
│                 設計書（統一形式）                          │
│                       │                                    │
│        ┌──────────────┼──────────────┐                     │
│        ▼              ▼              ▼                     │
│   人間が目視     テストケース    ソースコード               │
│   確認           生成（自動）    生成（自動）               │
│                       │              │                     │
│                       └──────┬───────┘                     │
│                              ▼                             │
│                        実装 / 検証                         │
└─────────────────────────────────────────────────────────────┘
```

---

## 3. 設計書の要件

### 3.1 三つの役割

| 役割 | 要件 |
|------|------|
| **人間向け** | 要件が正しく反映されているか目視確認できる |
| **機械向け（テスト）** | テストケースを自動生成できる |
| **機械向け（実装）** | ソースコードを自動生成できる |

### 3.2 設計書に含める項目

| セクション | 内容 | 人間確認 | テスト生成 | 実装生成 |
|------------|------|:--------:|:----------:|:--------:|
| **基本情報** | クラス名、分類、責務 | ✅ | - | ✅ |
| **ユビキタス言語** | ドメイン用語と実装名の対応 | ✅ | - | - |
| **不変条件** | 常に成り立つべき条件 | ✅ | ✅ | ✅ |
| **プロパティ仕様** | 型、必須/任意、制約、デフォルト値 | ✅ | ✅ | ✅ |
| **コンストラクタ仕様** | 事前条件、事後条件 | ✅ | ✅ | ✅ |
| **メソッド仕様** | 事前条件、事後条件、計算ロジック | ✅ | ✅ | ✅ |
| **同値クラス・境界値** | テストパターンの分類 | ✅ | ✅ | - |
| **テストシナリオ** | Given-When-Then形式 | ✅ | ✅ | - |
| **要件トレース** | 要件IDとの紐付け | ✅ | - | - |

---

## 4. フォワード vs リバース

### 4.1 フォワード（メイン）

```
要件定義 → 設計書作成 → テスト生成 → 実装生成/実装
```

- 全項目を人間が記述
- 要件IDを最初から紐付け
- 理想的な開発フロー

### 4.2 リバース（サブ）

```
既存ソース → 設計書スケルトン生成 → 人間が補足 → テスト生成
```

- 自動抽出できる項目と、人間が補足する項目を明確に分離
- 既存プロジェクトへの適用時に使用

| 項目 | 自動抽出 | 人間が補足 |
|------|:--------:|:----------:|
| クラス名・型・シグネチャ | ✅ | - |
| 計算ロジック | ✅ | - |
| 同値クラス・境界値 | △（提案） | ✅（確認・追加） |
| 責務・不変条件 | △（推論） | ✅（確認） |
| **なぜそうなっているか** | ❌ | ✅（必須） |
| **要件IDとの紐付け** | ❌ | ✅（必須） |

---

## 5. 設計書フォーマット案

### 5.1 推奨構成

```
docs/specs/
├── domain/
│   ├── Project.spec.md      # 人間向け（Markdown）
│   └── Project.spec.yaml    # 機械向け（YAML）
└── requirements/
    └── REQ-EVM.md           # 要件定義
```

### 5.2 Markdown（人間向け）

- 基本情報、ユビキタス言語
- 不変条件表
- プロパティ仕様表
- メソッド仕様（事前/事後条件、同値クラス・境界値）
- Given-When-Thenシナリオ

### 5.3 YAML（機械向け）

```yaml
metadata:
  id: SPEC-PROJECT-001
  requirement_ids: [REQ-EVM-001]

invariants:
  - id: INV-01
    expression: this.baseDate !== undefined

methods:
  - name: toTaskRows
    test_cases:
      - id: TC-001
        given: { taskNodes: [] }
        when: toTaskRows()
        then: { length: 0 }
```

---

## 6. 設計書からの生成物

| 生成物 | 生成元となる設計書の項目 |
|--------|------------------------|
| **テストコード** | 不変条件、事前/事後条件、同値クラス・境界値、テストシナリオ |
| **ソースコード** | プロパティ仕様、メソッドシグネチャ、計算ロジック/アルゴリズム |

---

## 7. 実験として作成した成果物

### 7.1 Projectクラス詳細仕様書

Projectクラスを題材に、テストケース導出可能な詳細仕様書を作成した。

含まれる内容：
- 基本情報（集約ルート、責務、ユビキタス言語）
- 不変条件（7項目）
- プロパティ仕様（コンストラクタ引数、公開プロパティ）
- コンストラクタ仕様（事前条件、事後条件）
- メソッド仕様（8メソッド、各メソッドに同値クラス・境界値）
- テストシナリオ（Given-When-Then形式、約40ケース）

---

## 8. 次のアクション候補

1. **設計書YAMLスキーマの詳細定義**
   - 統一形式を確定する

2. **テストジェネレーターのプロトタイプ作成**
   - Project仕様書 → Jestテストコード

3. **ソースコードジェネレーターの検討**
   - 設計書 → TypeScriptクラススケルトン

4. **リバースジェネレーターの検討**
   - 既存ソース → 設計書スケルトン

---

## 9. 関連する議論

### 9.1 DDD/クリーンアーキテクチャ準拠性分析

本プロジェクトの問題点として以下が特定された：

**Critical**:
- ドメイン層がExcelライブラリに依存（TaskRow.ts）
- ドメイン層がプレゼンテーション層に依存（ProjectProgressCreator.ts）

**Major**:
- インターフェース実装がドメイン層に混在
- ユースケース層がExcel出力ロジックを直接実装

これらの改善と、設計書駆動開発の導入を並行して進めることが望ましい。

---

## 10. 議論・Q&A

### 10.1 用語解説

#### Q: 「ユビキタス言語」とは？

**A:** DDD（ドメイン駆動設計）の専門用語。**ドメイン（業務）の用語と、コード上の命名を一致させた共通語彙**のこと。

例：
| 業務で使う言葉 | コード上の名前 |
|--------------|---------------|
| 基準日 | `baseDate` |
| 計画価値 | `pv` |

→ 分かりやすさのため「**ユビキタス言語（ドメイン用語）**」と併記することにした。

---

#### Q: 「境界づけられたコンテキスト」とは？

**A:** DDDの用語。**あるドメインモデル（用語や概念）が有効な「範囲・境界」を明示するもの**。

大規模システムでは、同じ言葉でも部門によって意味が異なることがある：

| 用語 | 販売コンテキスト | 配送コンテキスト |
|------|-----------------|-----------------|
| 「注文」 | 顧客の購入意思 | 届ける荷物 |

本プロジェクトは単一コンテキストだが、DDD用語を残すため「**境界づけられたコンテキスト（所属ドメイン）**」と併記することにした。

---

#### Q: 「不変条件（Invariants）」とは？

**A:** DDDというより**契約による設計（Design by Contract）**の概念。**オブジェクトのライフサイクル全体で常に成り立つべき条件**。

| 種類 | タイミング | 例 |
|------|-----------|-----|
| **事前条件** | メソッド呼び出し**前** | 「引数idは正の数」 |
| **事後条件** | メソッド呼び出し**後** | 「戻り値は配列」 |
| **不変条件** | **常に** | 「baseDateは常に存在」 |

不変条件は**全てのテストで検証すべき**条件となる。

---

#### Q: 「同値クラス・境界値」とは？

**A:** **テスト設計技法**の用語。

**同値クラス（同値分割法）**: 入力値を「同じ振る舞いをするグループ」に分け、各クラスから1つテストすれば十分とする考え方。

**境界値（境界値分析）**: 同値クラスの「境目」を重点的にテストする技法。バグは境界付近に集中するため有効。

例：進捗率（0.0〜1.0）の場合
```
   無効     │    有効     │    無効
 ← -0.1 ─── 0.0 ─────── 1.0 ─── 1.1 →
           ↑           ↑
         境界値       境界値
```

---

### 10.2 IDの用途

#### Q: 仕様書内のIDはどのように使う？

**A:** **トレーサビリティ（追跡可能性）**のために使用。

| ID接頭辞 | 例 | 意味 |
|---------|-----|------|
| `INV-` | INV-01 | 不変条件 |
| `PRE-` | PRE-C01 | 事前条件 |
| `POST-` | POST-TR01 | 事後条件 |
| `METHOD-` | METHOD-001 | メソッド |
| `EQ-` | EQ-TR-001 | 同値クラス |
| `TC-` | TC-TR-001 | テストケース |
| `BR-` | BR-SP-01 | ビジネスルール |

**用途：**
1. テストコードとの紐付け（`test('TC-TR-001: ...')`）
2. 要件へのトレース（REQ → METHOD → TC）
3. レビュー・障害対応時の特定

---

### 10.3 スキーマ拡張の議論

#### Q: ビジネスロジックはどこに記述する？

**背景:** 「カレンダー登録機能」のように、外部システム連携を含む処理をどう記述するか。

**検討結果:** 以下の2項目をスキーマに追加。

##### `business_rules`（ビジネスルール）

| 既存項目 | 性質 | 例 |
|---------|------|-----|
| `algorithm` | 処理**手順** | 1. 認証する 2. 登録する |
| `preconditions` | 呼び出し**前提** | 引数が有効であること |
| **`business_rules`** | **ドメインの制約** | 過去日時には登録不可 |

ビジネスルールは：
- 要件から直接導出される
- テストケースに直結する（ルール違反時の動作）
- `algorithm`に埋もれると見落としやすい

```yaml
business_rules:
  - id: BR-01
    rule: 過去の日時には登録できない
    on_violation: ValidationError
```

##### `external_dependencies`（外部依存）

| 観点 | 効果 |
|------|------|
| テスト設計 | モックすべき対象が明確になる |
| 影響分析 | 外部APIの変更時、影響範囲が分かる |
| 障害対応 | 「どこと連携しているか」が即座に分かる |

```yaml
external_dependencies:
  - name: Google Calendar API
    type: REST API
    description: カレンダー登録先
```

---

## 11. ドメイン層全体への仕様書展開（2025-12-16 追加）

### 11.1 概要

Project, ProjectCreatorに続き、domain層の全ファイルに対して仕様書を作成した。

### 11.2 作成した仕様書一覧

```
docs/specs/domain/
├── Project.spec.md           # 集約ルート
├── Project.spec.yaml
├── ProjectCreator.spec.md    # ポート + 実装3クラス
├── ProjectCreator.spec.yaml
├── TaskRow.spec.md           # エンティティ（EVM計算の中核）
├── TaskRow.spec.yaml
├── TaskNode.spec.md          # エンティティ（ツリー構造）
├── TaskNode.spec.yaml
├── TaskService.spec.md       # ドメインサービス
├── TaskService.spec.yaml
├── ProjectService.spec.md    # ドメインサービス（差分計算）
├── ProjectService.spec.yaml
├── HolidayData.spec.md       # 値オブジェクト
├── HolidayData.spec.yaml
├── Interfaces.spec.md        # ポート/リポジトリ（4件）
└── Interfaces.spec.yaml
```

### 11.3 各仕様書の概要

| クラス/インターフェース | 分類 | テストケース数 | 特記事項 |
|------------------------|------|--------------|----------|
| **TaskRow** | エンティティ | 約40件 | EVM計算の中核。calculatePV, calculatePVs, calculateSPI, calculateSV等 |
| **TaskNode** | エンティティ | 約7件 | TaskRowを継承、Iterable実装でツリー走査 |
| **TaskService** | ドメインサービス | 約9件 | buildTaskTree, convertToTaskRows |
| **ProjectService** | ドメインサービス | 約15件 | 差分計算、統計マージ、日付補間 |
| **HolidayData** | 値オブジェクト | 約4件 | イミュータブルな祝日データ |
| **TaskRowCreator** | ポート | 約3件 | TaskRow[]生成の抽象化 |
| **ProjectRepository** | リポジトリ | 約2件 | Project永続化の抽象化 |
| **ProjectProgressCreator** | ポート | 約2件 | **課題: プレゼンテーション層依存** |
| **ProjectStatisticsCreator** | ポート | 約4件 | **課題: 実装が同一ファイル** |

### 11.4 発見された設計上の課題

仕様書作成を通じて、以下の課題を改めて文書化した：

| 課題 | 対象ファイル | 詳細 |
|------|-------------|------|
| ドメイン層がプレゼンテーション層に依存 | `ProjectProgressCreator.ts` | `ProjectProgress`型が`presentation/project-test2.ts`で定義 |
| インターフェースと実装が同一ファイル | `ProjectStatisticsCreator.ts` | ExcelProjectStatisticsCreator等が同居 |
| ドメイン層がExcelライブラリに依存 | `TaskRow.ts`, `ProjectStatisticsCreator.ts` | `excel-csv-read-write`をimport |
| マジックナンバー | `MappingProjectCreator.ts` | 基準日の列番号`26`がハードコード |

### 11.5 リバース仕様書作成のプロセス

今回の仕様書作成は「リバース」フローで行った：

```
1. ソースコード読み込み
2. 既存テストファイル確認（TaskRow.test.ts, ProjectService.test.ts）
3. 仕様書スケルトン生成（Markdown）
4. YAML形式への変換
```

**自動抽出できた項目：**
- クラス名、型、シグネチャ
- 計算ロジック（algorithm）
- 同値クラス・境界値（テストから逆算）

**人間による補足が必要な項目：**
- 責務の明確化
- 不変条件の言語化
- ビジネスルールの抽出
- 要件IDとの紐付け（今回は未実施）

---

## 12. 参考

- 本ブレストで作成したProjectクラス詳細仕様書: `docs/specs/domain/Project.spec.md`
- YAMLスキーマ定義: `docs/specs/spec-schema.md`
- YAML形式仕様書: `docs/specs/domain/Project.spec.yaml`
- domain層全体の仕様書: `docs/specs/domain/` 配下の全ファイル

---

## 13. 追加議論: 仕様駆動開発 vs PRベース開発

**日付**: 2025-12-16
**参加者**: masatomix, Claude

### 13.1 批判的視点からの問い

> 「PRの中で修正されたソース（=コミットされたソース）を確認することは、すなわちトレーサビリティではないのか？」

### 13.2 PRコミット履歴でわかること

| 項目 | PRで確認可能か |
|------|:-------------:|
| 何を変えたか（diff） | ✓ |
| いつ変えたか（履歴） | ✓ |
| 誰が変えたか（author） | ✓ |
| なぜ変えたか | △（PR説明文次第） |

### 13.3 PRだけでは曖昧になりがちなこと

- この機能の「目的」は何だったか
- どういう入出力を想定していたか
- 受け入れ基準は何だったか
- 1年後に「このコードなぜこうなってる？」の答え

### 13.4 使い分けの結論

| 状況 | 仕様駆動開発 | PRベース |
|------|:-----------:|:--------:|
| 小規模チーム・個人開発 | 過剰かも | ✓ 十分 |
| バグ修正・小さな改善 | 過剰 | ✓ 十分 |
| 重要な機能追加 | ✓ 価値あり | △ |
| 外部との合意形成が必要 | ✓ 必須 | ✗ |
| 規制対応・監査 | ✓ 必須 | ✗ |
| 長期メンテナンス | ✓ 価値あり | △ |

### 13.5 結論

「PRで十分」なケースは多い。仕様駆動開発は**全部に適用するものではなく、必要な場面で使う**のが現実的。

本プロジェクトでは、以下の方針とする：
- **重要な新機能**: 仕様駆動開発フローを適用
- **バグ修正・軽微な改善**: PRベースで十分
- **判断に迷う場合**: Claude Codeに相談して決定
